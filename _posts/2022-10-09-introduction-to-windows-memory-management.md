Memory management is an essential function of every operating system. This article describes the basics of memory management and its implementation in Windows.

The basic goals of an operating system is to control and allocate the computer's hardware resources. Computers are composed of computing resources (CPU), memory resources, and input/output devices. Computers can only run programs when they are loaded in memory. Memory comes in diferent flavors depending on the type of the compute. A typical computer has 3 levels of memory. The first is memory close to the CPU. This is the fastest and composed of registers inside the CPU, and cache memory on the CPU chip itself. The secodn level is main memory. Main memory is commonly reffered to as Random Access Memory (RAM). RAM is much larger than cache memory, however latency is higher. RAM is also volatile. It is wiped out when the computer loses power. The third level of memory is disk. Disk is the largest and slowest of all memory types. Disk memory is non-volatile. It can hold data even when computer loses power. However, latency is order of magnitudes larger than cache and main memory. Disk is not accessed directly by the CPU. Any data stored on disk has to be loaded into main memory or the cache for the CPU to access it. 

Programs and the data they work on are first stored on disk. Before programs can run they have to be loaded into the main memory and encapsulated in a process at the CPU level. A process has pointers to the section of memory that belongs to it. The allocation of memory to processes is called address binding and can be done at compile time, at load time, or at run time. The main memory is a finit, continuous array of blocks. Each blog has a physical address. Since memory is finite, a few processes can quickly take over the entire memory. The job of the memory management unit of the OS is to intelligently allocate that finite set of memory resources to processes that are in aggregate larger than the available memory. To do so, the OS makes use of two techniques. First it assigns logical addresses to processes and maps them to actual physical memory addresses. This allows the OS to move parts or whole processes around without changing what the program sees. Second, it makes uses of the available space on disk by swaping idle processes out to it when there is not enough memory. 